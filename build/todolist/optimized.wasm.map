{"version":3,"sources":["~lib/internal/allocator.ts","~lib/allocator/arena.ts","node_modules/assemblyscript/std/assembly/internal/allocator.ts","node_modules/assemblyscript/std/assembly/internal/string.ts","contracts/datastream.ts","contracts/utils.ts","~lib/internal/arraybuffer.ts","~lib/internal/typedarray.ts","~lib/memory.ts","contracts/todolist/todo.ts","~lib/string.ts","~lib/internal/string.ts"],"names":[],"mappings":"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","sourceRoot":"assemblyscript:///","sourceContents":["/** Number of alignment bits. */\nexport const AL_BITS: u32 = 3;\n\n/** Number of possible alignment values. */\nexport const AL_SIZE: usize = 1 << <usize>AL_BITS;\n\n/** Mask to obtain just the alignment bits. */\nexport const AL_MASK: usize = AL_SIZE - 1;\n\n/** Maximum 32-bit allocation size. */\nexport const MAX_SIZE_32: usize = 1 << 30; // 1GB\n","/**\n * Arena Memory Allocator\n *\n * Provides a `reset_memory` function to reset the heap to its initial state. A user has to make\n * sure that there are no more references to cleared memory afterwards. Always aligns to 8 bytes.\n *\n * @module std/assembly/allocator/arena\n *//***/\n\nimport { AL_MASK, MAX_SIZE_32 } from \"../internal/allocator\";\n\nvar startOffset: usize = (HEAP_BASE + AL_MASK) & ~AL_MASK;\nvar offset: usize = startOffset;\n\n@global\nexport function allocate_memory(size: usize): usize {\n  if (size) {\n    if (size > MAX_SIZE_32) unreachable();\n    let ptr = offset;\n    let newPtr = (ptr + size + AL_MASK) & ~AL_MASK;\n    let pagesBefore = current_memory();\n    if (newPtr > <usize>pagesBefore << 16) {\n      let pagesNeeded = ((newPtr - ptr + 0xffff) & ~0xffff) >>> 16;\n      let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n      if (grow_memory(pagesWanted) < 0) {\n        if (grow_memory(pagesNeeded) < 0) {\n          unreachable(); // out of memory\n        }\n      }\n    }\n    offset = newPtr;\n    return ptr;\n  }\n  return 0;\n}\n\n@global\nexport function free_memory(ptr: usize): void {\n  // nop\n}\n\n@global\nexport function reset_memory(): void {\n  offset = startOffset;\n}\n","/** Number of alignment bits. */\nexport const AL_BITS: u32 = 3;\n\n/** Number of possible alignment values. */\nexport const AL_SIZE: usize = 1 << <usize>AL_BITS;\n\n/** Mask to obtain just the alignment bits. */\nexport const AL_MASK: usize = AL_SIZE - 1;\n\n/** Maximum 32-bit allocation size. */\nexport const MAX_SIZE_32: usize = 1 << 30; // 1GB\n","import {\n  MAX_SIZE_32\n} from \"./allocator\";\n\nimport {\n  String\n} from \"../string\";\n\n/** Size of a String header. */\nexport const HEADER_SIZE = (offsetof<String>() + 1) & ~1; // 2 byte aligned\n\n/** Maximum length of a String. */\nexport const MAX_LENGTH = (<i32>MAX_SIZE_32 - HEADER_SIZE) >>> 1;\n\n/** Singleton empty String. */\nexport const EMPTY = changetype<String>(\"\"); // TODO: is this a bad idea with '===' in place?\n\n/** Allocates a raw String with uninitialized contents. */\nexport function allocate(length: i32): String {\n  assert(length > 0 && length <= MAX_LENGTH);\n  var buffer = allocate_memory(HEADER_SIZE + (<usize>length << 1));\n  store<i32>(buffer, length);\n  return changetype<String>(buffer);\n}\n\nexport function isWhiteSpaceOrLineTerminator(c: u16): bool {\n  switch (c) {\n    case 10:      // <LF>\n    case 13:      // <CR>\n    case 8232:    // <LS>\n    case 8233:    // <PS>\n    case 9:       // <TAB>\n    case 11:      // <VT>\n    case 12:      // <FF>\n    case 32:      // <SP>\n    case 160:     // <NBSP>\n    case 65279: { // <ZWNBSP>\n      return true;\n    }\n    default: return false;\n  }\n}\n\nexport const enum CharCode {\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5a,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  o = 0x6F,\n  x = 0x78,\n  z = 0x7A\n}\n\nexport function parse<T>(str: String, radix: i32 = 0): T {\n  var len: i32 = str.length;\n  if (!len) {\n    return <T>NaN;\n  }\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <i32>load<u16>(ptr, HEADER_SIZE);\n\n  // determine sign\n  var sign: T;\n  if (code == CharCode.MINUS) {\n    if (!--len) {\n      return <T>NaN;\n    }\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) {\n      return <T>NaN;\n    }\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = 1;\n  } else {\n    sign = 1;\n  }\n\n  // determine radix\n  if (!radix) {\n    if (code == CharCode._0 && len > 2) {\n      switch (<i32>load<u16>(ptr + 2, HEADER_SIZE)) {\n        case CharCode.B:\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.O:\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.X:\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n        default: {\n          radix = 10;\n        }\n      }\n    } else radix = 10;\n  } else if (radix < 2 || radix > 36) {\n    return <T>NaN;\n  }\n\n  // calculate value\n  var num: T = 0;\n  while (len--) {\n    code = <i32>load<u16>(ptr, HEADER_SIZE);\n    if (code >= CharCode._0 && code <= CharCode._9) {\n      code -= CharCode._0;\n    } else if (code >= CharCode.A && code <= CharCode.Z) {\n      code -= CharCode.A - 10;\n    } else if (code >= CharCode.a && code <= CharCode.z) {\n      code -= CharCode.a - 10;\n    } else {\n      break;\n    }\n    if (code >= radix) {\n      break;\n    }\n    num = (num * radix) + code;\n    ptr += 2;\n  }\n  return sign * num;\n}\n","// Credits to EOSArgentina\r\n// https://github.com/EOSArgentina/eostypescript\r\n\r\nimport {\r\n  HEADER_SIZE,\r\n  allocate,\r\n} from \"../node_modules/assemblyscript/std/assembly/internal/string\";\r\n\r\nexport class DataStream {\r\n\r\n  pos: u32 = 0\r\n\r\n  constructor(\r\n    public buffer: u32,\r\n    public len:    u32\r\n  ) {}\r\n\r\n  readVarint32(): u32 {\r\n    var value: u32 = 0;\r\n    var shift: u32 = 0;\r\n    do {\r\n      var b = this.read<u8>();\r\n      value |= <u32>(b & 0x7f) << (7 * shift++);\r\n    } while (b & 0x80);\r\n    return value;\r\n  }\r\n\r\n  writeVarint32(value : u32): void {\r\n    do {\r\n      let b : u8  = <u8>value & <u8>0x7f;\r\n      value >>= 7;\r\n      b |= ((value > 0 ? 1 : 0) << 7);\r\n      this.store<u8>(b);\r\n    } while( value );\r\n  }\r\n\r\n  store<T>(value : T) : void {\r\n    store<T>(this.buffer + this.pos, value);\r\n    this.pos += sizeof<T>();\r\n  }\r\n\r\n  read<T>() : T {\r\n    var value : T = load<T>(this.buffer + this.pos);\r\n    this.pos += sizeof<T>();\r\n    return value;\r\n  }\r\n\r\n  readVector<T>() : T {\r\n    var len = this.readVarint32();\r\n    if( len == 0 ) return new Array<T>();\r\n\r\n    var arr = new Array<T>(len);\r\n    for(let i : u32 = 0; i < len; i++) {\r\n      arr[i] = read<T>();\r\n    }\r\n\r\n    return arr;\r\n  }\r\n\r\n  readString() : string {\r\n    var len = this.readVarint32();\r\n    if(len == 0) return \"\";\r\n    let s = allocate(len);\r\n\r\n    var i: u32 = 0;\r\n    while(i<len) {\r\n      let b : u16 = this.read<u8>();\r\n      store<u16>(<usize>s + (i << 1), b, HEADER_SIZE);\r\n      i++;\r\n    }\r\n\r\n    return <string>s;\r\n  }\r\n\r\n  writeString(str : string) : void {\r\n    var len : i32 = str.length;\r\n    this.writeVarint32(len);\r\n    if(len == 0) return;\r\n\r\n    var ptr = str.toUTF8();\r\n        len = str.lengthUTF8;\r\n\r\n    move_memory(this.buffer + this.pos, <usize>ptr, len - 1);\r\n    this.pos += len - 1;\r\n  }\r\n};\r\n","import * as EOS from \"./eoslib\"\r\nimport { DataStream } from \"./datastream\";\r\nimport { allocate, HEADER_SIZE } from \"../node_modules/assemblyscript/std/assembly/internal/string\";\r\n\r\nexport const CHARACTER_MAP : string = \".12345abcdefghijklmnopqrstuvwxyz\";\r\n\r\n@inline\r\nexport function print(str: string) : void {\r\n  EOS.prints(str.toUTF8());\r\n}\r\n\r\n@inline\r\nexport function assert(condition: bool, msg : string = null) : void {\r\n  if(!condition) EOS.eosio_assert(0, msg ? msg.toUTF8() : 0);\r\n}\r\n\r\n@inline\r\nfunction char_to_symbol( c : i32 ) : u64 {\r\n  if(c >= 97 && c <= 122) return (c - 97) + 6;\r\n  if(c >= 49 && c <=  53) return (c - 49) + 1;\r\n  return 0;\r\n}\r\n\r\nexport function N(str: string) : u64 {\r\n  var name : u64 = 0;\r\n  var i    : i32 = 0;\r\n  var len  : i32 = str.length;\r\n  for(; i < len && i < 12 ; i++) {\r\n    name |= (char_to_symbol(str.charCodeAt(i)) & <u64>0x1f) << (64 - 5 * (i + 1));\r\n  }\r\n  name |= char_to_symbol(str.charCodeAt(12)) & <u64>0x0F;\r\n  return name;\r\n}\r\n\r\nexport class Name {\r\n  value : u64;\r\n\r\n  constructor(name : string = \"\") {\r\n    this.value = N(name);\r\n  }\r\n\r\n  to_string() : string {\r\n    let s = allocate(13);\r\n    let tmp = this.value;\r\n    let start = false;\r\n    for (let i = 0; i < 13; i++) {\r\n      // let index = <i16>(tmp & (i == 0 ? 0x0f : 0x1f));\r\n      let index = <i16>(tmp & ((<u64>(i == 0) << 4) | 0xf));\r\n      if (index != 0) { start = true; }\r\n      if (start) {\r\n        let char = CHARACTER_MAP.charCodeAt(index);\r\n        store<u16>(changetype<usize>(s) + ((12 - i) << 1), char, HEADER_SIZE);\r\n      }\r\n      tmp >>= (i == 0 ? 4 : 5);\r\n    }\r\n    return changetype<string>(s);\r\n  }\r\n}\r\n\r\nexport function get_ds() : DataStream {\r\n  let len : u32 = EOS.action_data_size();\r\n  let arr : Uint8Array = new Uint8Array(len);\r\n  EOS.read_action_data(changetype<usize>(arr.buffer), len);\r\n  let ds = new DataStream(changetype<usize>(arr.buffer), len);\r\n  return ds;\r\n}\r\n","import { AL_MASK, MAX_SIZE_32 } from \"./allocator\";\n\n/** Size of an ArrayBuffer header. */\nexport const HEADER_SIZE: usize = (offsetof<ArrayBuffer>() + AL_MASK) & ~AL_MASK;\n\n/** Maximum byte length of an ArrayBuffer. */\nexport const MAX_BLENGTH: i32 = <i32>MAX_SIZE_32 - HEADER_SIZE;\n\n/** Computes an ArrayBuffer's size in memory. */\nexport function computeSize(byteLength: i32): usize {\n  // round up to power of 2, with HEADER_SIZE=8:\n  // 0            -> 2^3  = 8\n  // 1..8         -> 2^4  = 16\n  // 9..24        -> 2^5  = 32\n  // ...\n  // MAX_LENGTH   -> 2^30 = 0x40000000 (MAX_SIZE_32)\n  return <usize>1 << <usize>(<u32>32 - clz<u32>(byteLength + HEADER_SIZE - 1));\n}\n\n/** Allocates a raw ArrayBuffer. Contents remain uninitialized. */\nexport function allocUnsafe(byteLength: i32): ArrayBuffer {\n  assert(<u32>byteLength <= <u32>MAX_BLENGTH);\n  var buffer = allocate_memory(computeSize(byteLength));\n  store<i32>(buffer, byteLength, offsetof<ArrayBuffer>(\"byteLength\"));\n  return changetype<ArrayBuffer>(buffer);\n}\n\n/** Reallocates an ArrayBuffer, resizing it as requested. Tries to modify the buffer in place. */\nexport function reallocUnsafe(buffer: ArrayBuffer, newByteLength: i32): ArrayBuffer {\n  var oldByteLength = buffer.byteLength;\n  if (newByteLength > oldByteLength) {\n    assert(newByteLength <= MAX_BLENGTH);\n    if (newByteLength <= <i32>(computeSize(oldByteLength) - HEADER_SIZE)) { // fast path: zero out additional space\n      store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\n      set_memory(\n        changetype<usize>(buffer) + HEADER_SIZE + <usize>oldByteLength,\n        0,\n        <usize>(newByteLength - oldByteLength)\n      );\n    } else { // slow path: copy to new buffer\n      let newBuffer = allocUnsafe(newByteLength);\n      move_memory(\n        changetype<usize>(newBuffer) + HEADER_SIZE,\n        changetype<usize>(buffer) + HEADER_SIZE,\n        <usize>oldByteLength\n      );\n      set_memory(\n        changetype<usize>(newBuffer) + HEADER_SIZE + <usize>oldByteLength,\n        0,\n        <usize>(newByteLength - oldByteLength)\n      );\n      return newBuffer;\n    }\n  } else if (newByteLength < oldByteLength) { // fast path: override size\n    // TBD: worth to copy and release if size is significantly less than before?\n    assert(newByteLength >= 0);\n    store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\n  }\n  return buffer;\n}\n\n@inline\nexport function loadUnsafe<T,V>(buffer: ArrayBuffer, index: i32): V {\n  return <V>load<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()), HEADER_SIZE);\n}\n\n@inline\nexport function storeUnsafe<T,V>(buffer: ArrayBuffer, index: i32, value: V): void {\n  store<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()), value, HEADER_SIZE);\n}\n\n@inline\nexport function loadUnsafeWithOffset<T,V>(buffer: ArrayBuffer, index: i32, byteOffset: i32): V {\n  return <V>load<T>(changetype<usize>(buffer) + <usize>byteOffset + (<usize>index << alignof<T>()), HEADER_SIZE);\n}\n\n@inline\nexport function storeUnsafeWithOffset<T,V>(buffer: ArrayBuffer, index: i32, value: V, byteOffset: i32): void {\n  store<T>(changetype<usize>(buffer) + <usize>byteOffset + (<usize>index << alignof<T>()), value, HEADER_SIZE);\n}\n","import {\n  HEADER_SIZE as HEADER_SIZE_AB,\n  MAX_BLENGTH,\n  allocUnsafe,\n  loadUnsafeWithOffset,\n  storeUnsafeWithOffset\n} from \"./arraybuffer\";\n\n/** Typed array base class. Not a global object. */\nexport abstract class TypedArray<T,V> {\n\n  readonly buffer: ArrayBuffer;\n  readonly byteOffset: i32;\n  readonly byteLength: i32;\n\n  constructor(length: i32) {\n    const MAX_LENGTH = <u32>MAX_BLENGTH / sizeof<T>();\n    if (<u32>length > MAX_LENGTH) throw new RangeError(\"Invalid typed array length\");\n    var byteLength = length << alignof<T>();\n    var buffer = allocUnsafe(byteLength);\n    set_memory(changetype<usize>(buffer) + HEADER_SIZE_AB, 0, <usize>byteLength);\n    this.buffer = buffer;\n    this.byteOffset = 0;\n    this.byteLength = byteLength;\n  }\n\n  get length(): i32 {\n    return (this.byteLength - this.byteOffset) >> alignof<T>();\n  }\n\n  @operator(\"[]\")\n  protected __get(index: i32): T {\n    var byteOffset = this.byteOffset;\n    var elementLength = (this.byteLength - byteOffset) >>> alignof<T>();\n    if (<u32>index >= <u32>elementLength) throw new Error(\"Index out of bounds\");\n    return loadUnsafeWithOffset<T,T>(this.buffer, index, byteOffset);\n  }\n\n  @operator(\"{}\")\n  protected __unchecked_get(index: i32): T {\n    return loadUnsafeWithOffset<T,T>(this.buffer, index, this.byteOffset);\n  }\n\n  @operator(\"[]=\")\n  protected __set(index: i32, value: V): void {\n    var byteOffset = this.byteOffset;\n    var elementLength = (this.byteLength - byteOffset) >>> alignof<T>();\n    if (<u32>index >= <u32>elementLength) throw new Error(\"Index out of bounds\");\n    storeUnsafeWithOffset<T,V>(this.buffer, index, value, byteOffset);\n  }\n\n  @operator(\"{}=\")\n  protected __unchecked_set(index: i32, value: V): void {\n    storeUnsafeWithOffset<T,V>(this.buffer, index, value, this.byteOffset);\n  }\n\n  // copyWithin(target: i32, start: i32, end: i32 = this.length): this\n\n  @inline\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): TypedArray<T,V> {\n    var length = this.length;\n    if (begin < 0) begin = max(length + begin, 0);\n    else begin = min(begin, length);\n    if (end < 0) end = max(length + end, begin);\n    else end = max(min(end, length), begin);\n    var slice = allocate_memory(offsetof<this>());\n    store<usize>(slice, this.buffer, offsetof<this>(\"buffer\"));\n    store<i32>(slice, begin << alignof<T>(), offsetof<this>(\"byteOffset\"));\n    store<i32>(slice, end << alignof<T>(), offsetof<this>(\"byteLength\"));\n    return changetype<this>(slice);\n  }\n}\n","function copy_memory(dest: usize, src: usize, n: usize): void {\n  // based on musl's implementation of memcpy\n  // not a future instruction and sufficiently covered by the upcoming move_memory intrinsic\n\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\nexport function move_memory(dest: usize, src: usize, n: usize): void {\n  // based on musl's implementation of memmove\n  // becomes obsolete once https://github.com/WebAssembly/bulk-memory-operations lands\n\n  if (dest == src) return;\n  if (src + n <= dest || dest + n <= src) {\n    copy_memory(dest, src, n);\n    return;\n  }\n  if (dest < src) {\n    if ((src & 7) == (dest & 7)) {\n      while (dest & 7) {\n        if (!n) return;\n        --n;\n        store<u8>(dest++, load<u8>(src++));\n      }\n      while (n >= 8) {\n        store<u64>(dest, load<u64>(src));\n        n    -= 8;\n        dest += 8;\n        src  += 8;\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if ((src & 7) == (dest & 7)) {\n      while ((dest + n) & 7) {\n        if (!n) return;\n        store<u8>(dest + --n, load<u8>(src + n));\n      }\n      while (n >= 8) {\n        n -= 8;\n        store<u64>(dest + n, load<u64>(src + n));\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\nexport function set_memory(dest: usize, c: u8, n: usize): void {\n  // based on musl's implementation of memset\n  // becomes obsolete once https://github.com/WebAssembly/bulk-memory-operations lands\n\n  // fill head and tail with minimal branching\n  if (!n) return;\n  store<u8>(dest, c);\n  store<u8>(dest + n - 1, c);\n  if (n <= 2) return;\n\n  store<u8>(dest + 1, c);\n  store<u8>(dest + 2, c);\n  store<u8>(dest + n - 2, c);\n  store<u8>(dest + n - 3, c);\n  if (n <= 6) return;\n  store<u8>(dest + 3, c);\n  store<u8>(dest + n - 4, c);\n  if (n <= 8) return;\n\n  // advance pointer to align it at 4-byte boundary\n  var k: usize = -dest & 3;\n  dest += k;\n  n -= k;\n  n &= -4;\n\n  var c32: u32 = <u32>-1 / 255 * c;\n\n  // fill head/tail up to 28 bytes each in preparation\n  store<u32>(dest, c32);\n  store<u32>(dest + n - 4, c32);\n  if (n <= 8) return;\n  store<u32>(dest + 4, c32);\n  store<u32>(dest + 8, c32);\n  store<u32>(dest + n - 12, c32);\n  store<u32>(dest + n - 8, c32);\n  if (n <= 24) return;\n  store<u32>(dest + 12, c32);\n  store<u32>(dest + 16, c32);\n  store<u32>(dest + 20, c32);\n  store<u32>(dest + 24, c32);\n  store<u32>(dest + n - 28, c32);\n  store<u32>(dest + n - 24, c32);\n  store<u32>(dest + n - 20, c32);\n  store<u32>(dest + n - 16, c32);\n\n  // align to a multiple of 8\n  k = 24 + (dest & 4);\n  dest += k;\n  n -= k;\n\n  // copy 32 bytes each\n  var c64: u64 = <u64>c32 | (<u64>c32 << 32);\n  while (n >= 32) {\n    store<u64>(dest, c64);\n    store<u64>(dest + 8, c64);\n    store<u64>(dest + 16, c64);\n    store<u64>(dest + 24, c64);\n    n -= 32;\n    dest += 32;\n  }\n}\n\nexport function compare_memory(vl: usize, vr: usize, n: usize): i32 {\n  // based on musl's implementation of memcmp\n  // provided because there's no proposed alternative\n  if (vl == vr) return 0;\n  while (n && load<u8>(vl) == load<u8>(vr)) {\n    n--;\n    vl++;\n    vr++;\n  }\n  return n ? <i32>load<u8>(vl) - <i32>load<u8>(vr) : 0;\n}\n","import 'allocator/arena';\r\nimport * as eos from '../eoslib';\r\nimport { DataStream } from '../datastream';\r\nimport { get_ds, N, assert, print, Name } from '../utils';\r\nimport { db_find_i64, printi, require_auth } from '../eoslib';\r\n\r\nclass Todo {\r\n    primary: u64;\r\n    task: string;\r\n    completed: bool;\r\n    creator: u64;\r\n    assignee: u64;\r\n    iterator : i32;\r\n\r\n    from_ds(ds : DataStream) : void {\r\n        this.primary = ds.read<u64>();\r\n        this.creator = ds.read<u64>();\r\n        this.assignee= ds.read<u64>();\r\n        this.completed= ds.read<bool>();\r\n        this.task = ds.readString();\r\n    }\r\n\r\n    to_ds() : DataStream {\r\n        let arr = new Uint8Array(this.task.length);\r\n        let ds = new DataStream(changetype<usize>(arr.buffer), this.task.length);\r\n        ds.store<u64>(this.primary);\r\n        ds.store<u64>(this.creator);\r\n        ds.store<u64>(this.assignee);\r\n        ds.store<bool>(this.completed);\r\n        ds.writeString(this.task);\r\n        return ds;\r\n    }\r\n\r\n    to_string() : string {\r\n        let creator = new Name();\r\n        creator.value = this.creator;\r\n        let assignee = new Name();\r\n        assignee.value = this.assignee;\r\n        return this.task.concat(\"|\").concat(assignee.to_string()).concat(\"|\").concat(creator.to_string());\r\n    }\r\n}\r\n\r\nclass TodoContract {\r\n    receiver : u64;\r\n    code : u64;\r\n    action : u64;\r\n    scope : u64;\r\n    table : u64;\r\n    primary : i32;\r\n\r\n    constructor(receiver: u64, code: u64, action: u64) {\r\n        this.receiver = receiver;\r\n        this.code = code;\r\n        this.action = action;\r\n        this.scope = N(\"todo\");\r\n        this.table = N(\"todo\");\r\n    }\r\n\r\n    get(key : u64) : void {\r\n        let todo = this.getTodoByKey(key);\r\n        print(todo.to_string());\r\n    }\r\n\r\n    add(task : string, creator : u64) : void {\r\n        assert(task.length > 0, \"Task is empty\");\r\n        eos.require_auth(creator);\r\n        let key : u64 = 0;\r\n        let end : i32 = eos.db_end_i64(this.code, this.scope, this.table);\r\n        let iterator : i32 = eos.db_lowerbound_i64(this.code, this.scope, this.table, 0);\r\n        if (iterator != end) {\r\n            iterator = eos.db_previous_i64(end, offsetof<this>(\"primary\"));\r\n            let len = eos.db_get_i64(iterator, 0, 0);\r\n            let arr = new Uint8Array(len);\r\n            eos.db_get_i64(iterator, changetype<usize>(arr.buffer), len);\r\n            let ds = new DataStream(changetype<usize>(arr.buffer), len);\r\n            let last_todo = new Todo();\r\n            last_todo.from_ds(ds);\r\n            key = last_todo.primary + 1;\r\n        }\r\n\r\n        let todo = new Todo();\r\n        todo.primary = key;\r\n        todo.assignee = this.code;\r\n        todo.creator = creator;\r\n        todo.completed = false;\r\n        todo.task = task;\r\n        let ds_to_save = todo.to_ds();\r\n        iterator = eos.db_store_i64(this.scope, this.table, creator, todo.primary, ds_to_save.buffer, ds_to_save.pos);\r\n    }\r\n\r\n    removeAll() : void {\r\n        let iterator = eos.db_lowerbound_i64(this.code, this.scope, this.table, 0);\r\n        let i : i32 = 0;\r\n        while (iterator >= 0) {\r\n            let del = iterator;\r\n            iterator = eos.db_next_i64(iterator, changetype<usize>(this) + offsetof<this>(\"primary\"));\r\n            //print(\"\\nPrimary: \");\r\n            //eos.printi(this.primary);\r\n            eos.db_remove_i64(del);\r\n            i++;\r\n          }\r\n        print(\"Removed \");\r\n        eos.printi(i);\r\n    }\r\n\r\n    update(key : u64, completed : bool) : void {\r\n        let todo = this.getTodoByKey(key);\r\n        require_auth(todo.creator);\r\n        todo.completed = completed;\r\n        let ds = todo.to_ds();\r\n        eos.db_update_i64(todo.iterator, todo.creator, changetype<usize>(ds.buffer), ds.pos);\r\n    }\r\n\r\n    remove(key : u64) : void {\r\n        let todo = this.getTodoByKey(key);\r\n        require_auth(todo.creator);\r\n        eos.db_remove_i64(todo.iterator);\r\n    }\r\n\r\n    assign(key : u64, assignee : u64) : void {\r\n        let todo = this.getTodoByKey(key);\r\n        require_auth(todo.creator);\r\n        todo.assignee = assignee;\r\n        let ds = todo.to_ds();\r\n        eos.db_update_i64(todo.iterator, todo.creator, changetype<usize>(ds.buffer), ds.pos);\r\n    }\r\n\r\n    private getTodoByKey(key : u64) : Todo {\r\n        let iterator = eos.db_find_i64(this.code, this.scope, this.table, key);\r\n        let len = eos.db_get_i64(iterator, 0, 0);\r\n        assert(len >= 0, \"invalid length\");\r\n        let arr = new Uint8Array(len);\r\n        eos.db_get_i64(iterator, changetype<usize>(arr.buffer), len);\r\n\r\n        let output = new DataStream(changetype<usize>(arr.buffer), len);\r\n        let todo = new Todo();\r\n        todo.iterator = iterator;\r\n        todo.from_ds(output);\r\n        return todo;\r\n    }\r\n}\r\n\r\nexport function apply(receiver: u64, code: u64, action: u64) : void {\r\n    let ds = get_ds();\r\n    let contract = new TodoContract(receiver, code, action);\r\n    if (action == N('add')) {\r\n       contract.add(ds.readString(), ds.read<u64>());\r\n    }\r\n    else if (action == N('get')) {\r\n       contract.get(ds.readVarint32());\r\n    }\r\n    else if (action == N('update')) {\r\n       contract.update(ds.read<u64>(), ds.read<bool>());\r\n    }\r\n    else if (action == N('remove')) {\r\n       contract.remove(ds.read<u64>());\r\n    }\r\n    else if (action == N('removeall')) {\r\n        contract.removeAll();\r\n    }\r\n    else if (action == N('assign')) {\r\n        contract.assign(ds.read<u64>(), ds.read<u64>());\r\n    }\r\n    else {\r\n        print(\"Action not found\");\r\n    }\r\n}\r\n","import {\n  HEADER_SIZE,\n  MAX_LENGTH,\n  EMPTY,\n  allocate,\n  isWhiteSpaceOrLineTerminator,\n  CharCode,\n  parse\n} from \"./internal/string\";\n\n@sealed\nexport class String {\n\n  readonly length: i32; // capped to [0, MAX_LENGTH]\n\n  @operator(\"[]\")\n  charAt(pos: i32): String {\n    assert(this !== null);\n\n    if (<u32>pos >= <u32>this.length) {\n      return EMPTY;\n    }\n\n    var out = allocate(1);\n    store<u16>(\n      changetype<usize>(out),\n      load<u16>(\n        changetype<usize>(this) + (<usize>pos << 1),\n        HEADER_SIZE\n      ),\n      HEADER_SIZE\n    );\n    return out;\n  }\n\n  charCodeAt(pos: i32): i32 {\n    assert(this !== null);\n    if (<u32>pos >= <u32>this.length) {\n      return -1; // (NaN)\n    }\n    return load<u16>(\n      changetype<usize>(this) + (<usize>pos << 1),\n      HEADER_SIZE\n    );\n  }\n\n  codePointAt(pos: i32): i32 {\n    assert(this !== null);\n    if (<u32>pos >= <u32>this.length) {\n      return -1; // (undefined)\n    }\n    var first = <i32>load<u16>(\n      changetype<usize>(this) + (<usize>pos << 1),\n      HEADER_SIZE\n    );\n    if (first < 0xD800 || first > 0xDBFF || pos + 1 == this.length) {\n      return first;\n    }\n    var second = <i32>load<u16>(\n      changetype<usize>(this) + ((<usize>pos + 1) << 1),\n      HEADER_SIZE\n    );\n    if (second < 0xDC00 || second > 0xDFFF) return first;\n    return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator(\"+\")\n  private static __concat(left: String, right: String): String {\n    if (!changetype<usize>(left)) left = changetype<String>(\"null\");\n    return left.concat(right);\n  }\n\n  concat(other: String): String {\n    assert(this !== null);\n    if (other === null) other = changetype<String>(\"null\");\n    var thisLen: isize = this.length;\n    var otherLen: isize = other.length;\n    var outLen: usize = thisLen + otherLen;\n    if (outLen == 0) return EMPTY;\n    var out = allocate(outLen);\n\n    move_memory(\n      changetype<usize>(out) + HEADER_SIZE,\n      changetype<usize>(this) + HEADER_SIZE,\n      thisLen << 1\n    );\n\n    move_memory(\n      changetype<usize>(out) + HEADER_SIZE + (thisLen << 1),\n      changetype<usize>(other) + HEADER_SIZE,\n      otherLen << 1\n    );\n\n    return out;\n  }\n\n  endsWith(searchString: String, endPosition: i32 = MAX_LENGTH): bool {\n    assert(this !== null);\n    if (searchString === null) return false;\n    var end: isize = <isize>min(max(endPosition, 0), this.length);\n    var searchLength: isize = searchString.length;\n    var start: isize = end - searchLength;\n    if (start < 0) return false;\n    return !compare_memory(\n      changetype<usize>(this) + HEADER_SIZE + (start << 1),\n      changetype<usize>(searchString) + HEADER_SIZE,\n      searchLength << 1\n    );\n  }\n\n  @operator(\"==\")\n  private static __eq(left: String, right: String): bool {\n    if (left === right) return true;\n    if (left === null || right === null) return false;\n\n    var leftLength = left.length;\n    if (leftLength != right.length) return false;\n\n    return !compare_memory(\n      changetype<usize>(left) + HEADER_SIZE,\n      changetype<usize>(right) + HEADER_SIZE,\n      (<usize>leftLength << 1)\n    );\n  }\n\n  @operator(\"!=\")\n  private static __ne(left: String, right: String): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(\">\")\n  private static __gt(left: String, right: String): bool {\n    if (left === right || left === null || right === null) return false;\n\n    var leftLength  = left.length;\n    var rightLength = right.length;\n\n    if (!leftLength)  return false;\n    if (!rightLength) return true;\n\n    var length = <usize>min<i32>(leftLength, rightLength);\n    return compare_memory(\n      changetype<usize>(left)  + HEADER_SIZE,\n      changetype<usize>(right) + HEADER_SIZE,\n      length << 1\n    ) > 0;\n  }\n\n  @operator(\">=\")\n  private static __gte(left: String, right: String): bool {\n    if (left === right) return true;\n    if (left === null || right === null) return false;\n\n    var leftLength  = left.length;\n    var rightLength = right.length;\n\n    if (!leftLength)  return !rightLength;\n    if (!rightLength) return true;\n\n    var length = <usize>min<i32>(leftLength, rightLength);\n    return compare_memory(\n      changetype<usize>(left)  + HEADER_SIZE,\n      changetype<usize>(right) + HEADER_SIZE,\n      length << 1\n    ) >= 0;\n  }\n\n  @operator(\"<\")\n  private static __lt(left: String, right: String): bool {\n    if (left === right || left === null || right === null) return false;\n\n    var leftLength  = left.length;\n    var rightLength = right.length;\n\n    if (!rightLength) return false;\n    if (!leftLength)  return true;\n\n    var length = <usize>min<i32>(leftLength, rightLength);\n    return compare_memory(\n      changetype<usize>(left)  + HEADER_SIZE,\n      changetype<usize>(right) + HEADER_SIZE,\n      length << 1\n    ) < 0;\n  }\n\n  @operator(\"<=\")\n  private static __lte(left: String, right: String): bool {\n    if (left === right) return true;\n    if (left === null || right === null) return false;\n\n    var leftLength  = left.length;\n    var rightLength = right.length;\n\n    if (!rightLength) return !leftLength;\n    if (!leftLength)  return true;\n\n    var length = <usize>min<i32>(leftLength, rightLength);\n    return compare_memory(\n      changetype<usize>(left)  + HEADER_SIZE,\n      changetype<usize>(right) + HEADER_SIZE,\n      length << 1\n    ) <= 0;\n  }\n\n  includes(searchString: String, position: i32 = 0): bool {\n    return this.indexOf(searchString, position) != -1;\n  }\n\n  indexOf(searchString: String, position: i32 = 0): i32 {\n    assert(this !== null);\n    if (searchString === null) searchString = changetype<String>(\"null\");\n    var pos: isize = position;\n    var len: isize = this.length;\n    var start: isize = min<isize>(max<isize>(pos, 0), len);\n    var searchLen: isize = <isize>searchString.length;\n\n    // TODO: two-way, multiple char codes\n    for (let k: usize = start; <isize>k + searchLen <= len; ++k) {\n      if (!compare_memory(\n        changetype<usize>(this) + HEADER_SIZE + (k << 1),\n        changetype<usize>(searchString) + HEADER_SIZE,\n        searchLen << 1)\n      ) {\n        return <i32>k;\n      }\n    }\n    return -1;\n  }\n\n  startsWith(searchString: String, position: i32 = 0): bool {\n    assert(this !== null);\n    if (searchString === null) searchString = changetype<String>(\"null\");\n\n    var pos: isize = position;\n    var len: isize = this.length;\n    var start: isize = min<isize>(max<isize>(pos, 0), len);\n    var searchLength: isize = <isize>searchString.length;\n    if (searchLength + start > len) {\n      return false;\n    }\n    return !compare_memory(\n      changetype<usize>(this) + HEADER_SIZE + (start << 1),\n      changetype<usize>(searchString) + HEADER_SIZE,\n      searchLength << 1\n    );\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String {\n    assert(this !== null);\n    var intStart: isize = start;\n    var end: isize = length;\n    var size: isize = this.length;\n    if (intStart < 0) {\n      intStart = max<isize>(size + intStart, 0);\n    }\n    var resultLength: isize = min<isize>(max<isize>(end, 0), size - intStart);\n    if (resultLength <= 0) {\n      return EMPTY;\n    }\n    var out = allocate(resultLength);\n    move_memory(\n      changetype<usize>(out) + HEADER_SIZE,\n      changetype<usize>(this) + HEADER_SIZE + (intStart << 1),\n      <usize>resultLength << 1\n    );\n    return out;\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    assert(this !== null);\n    var len = this.length;\n    var finalStart = min<i32>(max<i32>(start, 0), len);\n    var finalEnd = min<i32>(max<i32>(end, 0), len);\n    var from = min<i32>(finalStart, finalEnd);\n    var to = max<i32>(finalStart, finalEnd);\n    len = to - from;\n    if (!len) {\n      return EMPTY;\n    }\n    if (!from && to == this.length) {\n      return this;\n    }\n    var out = allocate(len);\n    move_memory(\n      changetype<usize>(out) + HEADER_SIZE,\n      changetype<usize>(this) + HEADER_SIZE + (from << 1),\n      len << 1\n    );\n    return out;\n  }\n\n  trim(): String {\n    assert(this !== null);\n    var length: usize = this.length;\n\n    while (\n      length &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (length << 1), HEADER_SIZE)\n      )\n    ) {\n      --length;\n    }\n    var start: usize = 0;\n    while (\n      start < length &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (start << 1), HEADER_SIZE)\n      )\n    ) {\n      ++start, --length;\n    }\n    if (!length) {\n      return EMPTY;\n    }\n    if (!start && length == this.length) {\n      return this;\n    }\n    var out = allocate(length);\n    move_memory(\n      changetype<usize>(out) + HEADER_SIZE,\n      changetype<usize>(this) + HEADER_SIZE + (start << 1),\n      length << 1\n    );\n    return out;\n  }\n\n  trimLeft(): String {\n    assert(this !== null);\n    var start: isize = 0;\n    var len: isize = this.length;\n    while (\n      start < len &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (start << 1), HEADER_SIZE)\n      )\n    ) {\n      ++start;\n    }\n    if (!start) {\n      return this;\n    }\n    var outLen = len - start;\n    if (!outLen) {\n      return EMPTY;\n    }\n    var out = allocate(outLen);\n    move_memory(\n      changetype<usize>(out) + HEADER_SIZE,\n      changetype<usize>(this) + HEADER_SIZE + (start << 1),\n      outLen << 1\n    );\n    return out;\n  }\n\n  trimRight(): String {\n    assert(this !== null);\n    var len: isize = this.length;\n    while (\n      len > 0 &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (len << 1), HEADER_SIZE)\n      )\n    ) {\n      --len;\n    }\n    if (len <= 0) {\n      return EMPTY;\n    }\n    if (<i32>len == this.length) {\n      return this;\n    }\n    var out = allocate(len);\n    move_memory(\n      changetype<usize>(out) + HEADER_SIZE,\n      changetype<usize>(this) + HEADER_SIZE,\n      len << 1\n    );\n    return out;\n  }\n\n  repeat(count: i32 = 0): String {\n    assert(this !== null);\n    var length = this.length;\n\n    // Most browsers can't handle strings 1 << 28 chars or longer\n    if (count < 0 || length * count > (1 << 28)) {\n      throw new RangeError(\"Invalid count value\");\n    }\n\n    if (count === 0 || !length) return EMPTY;\n    if (count === 1) return this;\n\n    var result = allocate(length * count);\n    var strLen = length << 1;\n\n    /*\n     * TODO possible improvments: reuse existing result for exponentially concats like:\n     * 'a' + 'a' => 'aa' + 'aa' => 'aaaa' + 'aaaa' etc\n     */\n    for (let offset = 0, len = strLen * count; offset < len; offset += strLen) {\n      move_memory(\n        changetype<usize>(result) + HEADER_SIZE + offset,\n        changetype<usize>(this)   + HEADER_SIZE,\n        strLen\n      );\n    }\n\n    return result;\n  }\n\n  toString(): String {\n    return this;\n  }\n\n  get lengthUTF8(): i32 {\n    var len = 1; // null terminated\n    var pos: usize = 0;\n    var end = <usize>this.length;\n    while (pos < end) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (pos << 1), HEADER_SIZE);\n      if (c < 128) {\n        len += 1; ++pos;\n      } else if (c < 2048) {\n        len += 2; ++pos;\n      } else {\n        if (\n          (c & 0xFC00) == 0xD800 && pos + 1 < end &&\n          (<u32>load<u16>(changetype<usize>(this) + ((pos + 1) << 1), HEADER_SIZE) & 0xFC00) == 0xDC00\n        ) {\n          len += 4; pos += 2;\n        } else {\n          len += 3; ++pos;\n        }\n      }\n    }\n    return len;\n  }\n\n  toUTF8(): usize {\n    var buf = allocate_memory(<usize>this.lengthUTF8);\n    var pos: usize = 0;\n    var end = <usize>this.length;\n    var off: usize = 0;\n    while (pos < end) {\n      let c1 = <u32>load<u16>(changetype<usize>(this) + (pos << 1), HEADER_SIZE);\n      if (c1 < 128) {\n        store<u8>(buf + off, c1);\n        ++off; ++pos;\n      } else if (c1 < 2048) {\n        let ptr = buf + off;\n        store<u8>(ptr, c1 >> 6      | 192);\n        store<u8>(ptr, c1      & 63 | 128, 1);\n        off += 2; ++pos;\n      } else {\n        let ptr = buf + off;\n        if ((c1 & 0xFC00) == 0xD800 && pos + 1 < end) {\n          let c2 = <u32>load<u16>(changetype<usize>(this) + ((pos + 1) << 1), HEADER_SIZE);\n          if ((c2 & 0xFC00) == 0xDC00) {\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\n            store<u8>(ptr, c1 >> 18      | 240);\n            store<u8>(ptr, c1 >> 12 & 63 | 128, 1);\n            store<u8>(ptr, c1 >> 6  & 63 | 128, 2);\n            store<u8>(ptr, c1       & 63 | 128, 3);\n            off += 4; pos += 2;\n            continue;\n          }\n        }\n        store<u8>(ptr, c1 >> 12      | 224);\n        store<u8>(ptr, c1 >> 6  & 63 | 128, 1);\n        store<u8>(ptr, c1       & 63 | 128, 2);\n        off += 3; ++pos;\n      }\n    }\n    store<u8>(buf + off, 0);\n    return buf;\n  }\n}\n\nexport function parseInt(str: String, radix: i32 = 0): f64 {\n  return parse<f64>(str, radix);\n}\n\nexport function parseI32(str: String, radix: i32 = 0): i32 {\n  return parse<i32>(str, radix);\n}\n\nexport function parseI64(str: String, radix: i32 = 0): i64 {\n  return parse<i64>(str, radix);\n}\n\n// FIXME: naive implementation\nexport function parseFloat(str: String): f64 {\n  var len: i32 = str.length;\n  if (!len) {\n    return NaN;\n  }\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <i32>load<u16>(ptr, HEADER_SIZE);\n\n  // determine sign\n  var sign: f64;\n  if (code == CharCode.MINUS) {\n    if (!--len) {\n      return NaN;\n    }\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) {\n      return NaN;\n    }\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = 1;\n  } else {\n    sign = 1;\n  }\n\n  // calculate value\n  var num: f64 = 0;\n  while (len--) {\n    code = <i32>load<u16>(ptr, HEADER_SIZE);\n    if (code == CharCode.DOT) {\n      ptr += 2;\n      let fac: f64 = 0.1; // precision :(\n      while (len--) {\n        code = <i32>load<u16>(ptr, HEADER_SIZE);\n        if (code == CharCode.E || code == CharCode.e) {\n          assert(false); // TODO\n        }\n        code -= CharCode._0;\n        if (<u32>code > 9) {\n          break;\n        }\n        num += <f64>code * fac;\n        fac *= 0.1;\n        ptr += 2;\n      }\n      break;\n    }\n    code -= CharCode._0;\n    if (<u32>code >= 10) {\n      break;\n    }\n    num = (num * 10) + code;\n    ptr += 2;\n  }\n  return sign * num;\n}\n","import {\n  MAX_SIZE_32\n} from \"./allocator\";\n\nimport {\n  String\n} from \"../string\";\n\n/** Size of a String header. */\nexport const HEADER_SIZE = (offsetof<String>() + 1) & ~1; // 2 byte aligned\n\n/** Maximum length of a String. */\nexport const MAX_LENGTH = (<i32>MAX_SIZE_32 - HEADER_SIZE) >>> 1;\n\n/** Singleton empty String. */\nexport const EMPTY = changetype<String>(\"\"); // TODO: is this a bad idea with '===' in place?\n\n/** Allocates a raw String with uninitialized contents. */\nexport function allocate(length: i32): String {\n  assert(length > 0 && length <= MAX_LENGTH);\n  var buffer = allocate_memory(HEADER_SIZE + (<usize>length << 1));\n  store<i32>(buffer, length);\n  return changetype<String>(buffer);\n}\n\nexport function isWhiteSpaceOrLineTerminator(c: u16): bool {\n  switch (c) {\n    case 10:      // <LF>\n    case 13:      // <CR>\n    case 8232:    // <LS>\n    case 8233:    // <PS>\n    case 9:       // <TAB>\n    case 11:      // <VT>\n    case 12:      // <FF>\n    case 32:      // <SP>\n    case 160:     // <NBSP>\n    case 65279: { // <ZWNBSP>\n      return true;\n    }\n    default: return false;\n  }\n}\n\nexport const enum CharCode {\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5a,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  o = 0x6F,\n  x = 0x78,\n  z = 0x7A\n}\n\nexport function parse<T>(str: String, radix: i32 = 0): T {\n  var len: i32 = str.length;\n  if (!len) {\n    return <T>NaN;\n  }\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <i32>load<u16>(ptr, HEADER_SIZE);\n\n  // determine sign\n  var sign: T;\n  if (code == CharCode.MINUS) {\n    if (!--len) {\n      return <T>NaN;\n    }\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) {\n      return <T>NaN;\n    }\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = 1;\n  } else {\n    sign = 1;\n  }\n\n  // determine radix\n  if (!radix) {\n    if (code == CharCode._0 && len > 2) {\n      switch (<i32>load<u16>(ptr + 2, HEADER_SIZE)) {\n        case CharCode.B:\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.O:\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.X:\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n        default: {\n          radix = 10;\n        }\n      }\n    } else radix = 10;\n  } else if (radix < 2 || radix > 36) {\n    return <T>NaN;\n  }\n\n  // calculate value\n  var num: T = 0;\n  while (len--) {\n    code = <i32>load<u16>(ptr, HEADER_SIZE);\n    if (code >= CharCode._0 && code <= CharCode._9) {\n      code -= CharCode._0;\n    } else if (code >= CharCode.A && code <= CharCode.Z) {\n      code -= CharCode.A - 10;\n    } else if (code >= CharCode.a && code <= CharCode.z) {\n      code -= CharCode.a - 10;\n    } else {\n      break;\n    }\n    if (code >= radix) {\n      break;\n    }\n    num = (num * radix) + code;\n    ptr += 2;\n  }\n  return sign * num;\n}\n"]}